#### FUNCTION EXTRACT DATA FROM A DAILY GRID AND MAKE INPUTS FOR SWAT MODEL
################################################################################
#' @title  Function to extract Precipitation grid data from daily and make inputs for SWAT model
#' @param pr brick or stack raster/netcdf grid format of precipitation.
#' @param cores numeric. Number of cores to be used for the download. By default,
#' it automatically detects how many cores there are on your computer and
#' subtracts 1 to prevent it from slowing down.
#' @param Subbasins SpatialPolygonDataFrame object of subbasins generated by SWAT model.
#' @param DEM Raster .tif format of Digital Elevation Model which was used in the hydrological model.
#' @param dsn path. Directory to which you want to store the downloaded data.
#' @param Star_Date character. Initial date to extract the information.
#' @param Temporal character. Only \code{'day'} is aceptting for swat, but if you want to extract monthly data,
#' write as \code{'month'}
#'
#' @importFrom parallel detectCores makeCluster clusterEvalQ clusterExport stopCluster
#' @importFrom raster brick projection nlayers ncell extract as.matrix projectRaster
#' @importFrom sp proj4string CRS is.projected spTransform coordinates
#' @importFrom glue glue
#' @importFrom xfun dir_create
#' @importFrom tictoc tic toc tic.log tic.clearlog
#' @importFrom pbapply pblapply
#' @importFrom rgeos gCentroid
#' @importFrom dplyr mutate rename select
#' @importFrom ggplot2 fortify ggplot geom_polygon aes alpha geom_point scale_fill_manual labs theme element_rect
#' @importFrom ggthemes theme_pander
#'
#' @family Inputs Hidrological models
#'
#' @examples \dontrun{
#'
#' DEM <- raster::raster('Data/GRIDs/DEM.tif')
#' pr <- 'Data/GRIDs/prec_diaria.nc'
#' Subbasins <- rgdal::readOGR('Data/SHPs/subs.shp')
#' Star_Date = '1981-01-01'
#' Temporal = 'day'
#'
# # for precipitation
#' grid_pcp2SWAT(
#'   pr = pr,
#'   Subbasins = Subbasins,
#'  DEM = DEM,
#'   Star_Date = '1981-01-01',
#'   Temporal = 'day'
#' )
#'
#' }
#'
#'@export


grid_pcp2SWAT <- function(

  pr = NULL,
  Subbasins = NULL,
  DEM = NULL,
  cores = parallel::detectCores()-1,
  Star_Date = '1981-01-01',
  Temporal = 'day',
  dsn = getwd()
){
  # require(dplyr)
  options(warn = -1)
  #reading data to be used --------------------
  pr <- raster::brick(pr)
  sp::proj4string(pr) <- sp::CRS("+init=epsg:4326")
  sp::proj4string(Subbasins) <- sp::CRS("+init=epsg:4326")

  ##creating binder output --------------------
  outp1 <- glue::glue(dsn,'/SWAT_inputs/Precipitation/')
  ifelse(!dir.exists(outp1),xfun::dir_create(outp1),print('already exist!'))

  # verificar el shape
  if(!class(Subbasins) == 'SpatialPolygonsDataFrame') stop('subs shuold be a SpatialPolygonsDataFrame object', call. = FALSE)

  # verificar la proyeccion de subs con grid
  if(sp::is.projected(Subbasins)){
    stop('Error: Subbasins dont have projection', call. = FALSE)
  }  else {
    Subasins <- sp::spTransform(Subbasins, raster::projection(pr))
  }

  as.numeric(Subbasins@data$Subbasin)
  Star_Date <- as.Date(Star_Date)
  dates <- seq.Date(from = Star_Date,
                    length.out = raster::nlayers(pr),
                    by = Temporal)
  end_day <- tail(dates,1)

  tictoc::tic('timer')
  cat('\f')
  cat('------------------------------------------------------------------------\n')
  cat('Extracting data from period:', as.character(Star_Date), 'to', as.character(end_day),'at',Temporal,'scale\n')
  cat('------------------------------------------------------------------------\n')

  cell.numbers <- function(grid, geom){
    spacialcov <- grid
    spacialcov[] <- 1:raster::ncell(grid)
    position_rowcol <- function(i){
      quad1 <- unlist(raster::extract(x = spacialcov, y =  geom[i,], small = TRUE))
    }
    position <- lapply(1:length(geom), position_rowcol)
    return(position)
  }

  extract.fast <- function(grid, cells, fun = meam, na.rm = TRUE){
    matrix.r <- t(raster::as.matrix(grid))
    res <- sapply(1:length(cells), function(i){
      value <- matrix.r[cells[[i]]]
      fun(value, na.rm = na.rm)
    })
  }

  cell.numbers <- cell.numbers(grid = pr[[1]], geom = Subbasins)

  # Paralelizando
  if(!cores < parallel::detectCores()) cores <- parallel::detectCores()-1
  cl <- parallel::makeCluster(cores)

  parallel::clusterEvalQ(cl = cl, expr = c(library(raster)))
  parallel::clusterExport(cl = cl, varlist = c("pr",
                                               "cell.numbers",
                                               "extract.fast"),
                          envir = environment())

  # extracting data

  mean <- pbapply::pblapply(cl = cl,X = c(1:raster::nlayers(pr)), function(z){
    pre <- extract.fast(grid = pr[[z]],
                        cells = cell.numbers,
                        fun = mean,
                        na.rm = TRUE)

    return(pre)
  })

  parallel::stopCluster(cl)
  mean <- do.call(rbind, mean)

  lapply(1:ncol(mean), function(i){

    a <- round(mean[, i], 2)
    a[][is.na(a[])] <- -99

    b <- c(as.character(paste(format(Star_Date, "%Y"),
                              format(Star_Date, "%m"),
                              format(Star_Date, "%d"),
                              sep = '')), a)

    write.table(x = b, file = paste(outp1,'pcp_',
                                    sprintf(Subbasins@data$Subbasin[i]),
                                    '.txt',
                                    sep = ''),
                row.names = FALSE,
                quote = FALSE,
                col.names = FALSE)

  })


  ## making the general read table from pr
  cat('\f')
  cat('------------------------------------------------\n')
  cat('Writing main table of ubication for centroids!\n')
  cat('------------------------------------------------\n')
  subs <- sp::spTransform(Subbasins, sp::CRS("+proj=longlat +datum=WGS84 +no_defs "))
  centroids <- rgeos::gCentroid(spgeom = subs, byid = TRUE)
  centroids <- sp::coordinates(centroids)

  elev <- raster::extract(raster::projectRaster(from = DEM,crs = '+proj=longlat +datum=WGS84 +no_defs'),centroids)

  subbasins <- data.frame(ID = Subbasins@data$Subbasin,
                          NAME = paste('pcp_', Subbasins@data$Subbasin, sep = ''),
                          LAT = round(as.numeric(centroids[, 2]), 3),
                          LONG = round(as.numeric(centroids[, 1]), 3),
                          ELEVATION = round(as.numeric(elev), 3))

  write.table(subbasins, paste(outp1, "/", "pcp", ".txt", sep=""),row.names = FALSE, quote = FALSE, col.names = TRUE, sep = ",")

  ubication <- subbasins %>%
    dplyr::mutate(PRECIPITATION = paste0('pcp_',1:dim(subbasins)[1])) %>%
    dplyr::rename(TEMPERATURE = NAME) %>%
    dplyr::select(ID, TEMPERATURE, PRECIPITATION,LAT,LONG,ELEVATION)

  fotify <- ggplot2::fortify(Subasins)

  g <- ggplot2::ggplot()+
    ggplot2::geom_polygon(data = fotify, ggplot2::aes(long, lat, group = group, fill = hole),
                          colour = ggplot2::alpha("darkred", 1/2), size = 0.7) +
    ggplot2::geom_point(data = ubication, ggplot2::aes(LONG,LAT, size = ELEVATION), color = 'black', ptch = 16)+
    ggplot2::scale_fill_manual(values = c("gray95", "white")) +
    ggthemes::theme_pander()+
    ggplot2::labs(x = 'Longitude', y = 'Latitude', title = 'Points from which the information for each sub-basin was extracted',
                  subtitle = 'larger dots indicate higher altitude', caption = 'Plot generating by RWeatherTools R Package')+
    ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white"),
                   legend.position = "none")


  tictoc::toc(log = TRUE, quiet = TRUE)
  log.txt <- tictoc::tic.log(format = FALSE)
  tictoc::tic.clearlog()
  timings <- unlist(lapply(log.txt, function(x) x$toc - x$tic))
  cat('\f')
  cat('----------------------------------------------------------------------\n')
  message('Time elapsed for pcp extraction:', round(timings/60,2),'minutes\n')
  cat('----------------------------------------------------------------------\n')

  gc(reset = TRUE)
  return(print(g))

}


###############################################################################
#### FUNCTION EXTRACT DATA FROM A DAILY GRID AND MAKE INPUTS FOR SWAT MODEL
################################################################################

#' @title Function to extract Temperature grid data from daily and make inputs for SWAT model
#' @param tx brick or stack raster/netcdf grid format of maximun temperature.
#' @param tn brick or stack raster/netcdf grid format of minimun temperature.
#' @param cores numeric. Number of cores to be used for the download. By default,
#' it automatically detects how many cores there are on your computer and
#' subtracts 1 to prevent it from slowing down.
#' @param Subbasins SpatialPolygonDataFrame object of subbasins generated by SWAT model.
#' @param DEM Raster .tif format of Digital Elevation Model which was used in the hydrological model.
#' @param dsn path. Directory to which you want to store the downloaded data.
#' @param Star_Date character. Initial date to extract the information.
#' @param Temporal character. Only \code{'day'} is aceptting for swat, but if you want to extract monthly data, write as \code{'month'}
#'
#' @importFrom parallel detectCores makeCluster clusterEvalQ clusterExport stopCluster
#' @importFrom raster brick projection nlayers ncell extract as.matrix projectRaster
#' @importFrom sp proj4string CRS is.projected spTransform coordinates
#' @importFrom glue glue
#' @importFrom xfun dir_create
#' @importFrom tictoc tic toc tic.log tic.clearlog
#' @importFrom pbapply pblapply
#' @importFrom rgeos gCentroid
#' @importFrom dplyr mutate rename select %>%
#' @importFrom ggplot2 fortify ggplot geom_polygon aes alpha geom_point scale_fill_manual labs theme element_rect
#' @importFrom ggthemes theme_pander
#' @family Inputs Hidrological models
#' @author Crhistian Cornejo
#'
#' @family Inputs SWAT
#'
#' @examples \dontrun{
#' DEM <- raster::raster('Data/GRIDs/DEM.tif')
#' tx <- 'Data/GRIDs/tmax_diaria.nc'
#' tn <- 'Data/GRIDs/tmin_diaria.nc'
#' Subbasins <- rgdal::readOGR('Data/SHPs/subs.shp')
#' Star_Date = '1981-01-01'
#' Temporal = 'day'
# for temperature
#' grid_tas2SWAT (
#'  tx = tx,
#'  tn = tn,
#'  Subbasins = Subbasins,
#'  DEM = DEM,
#'  Star_Date = '1981-01-01',
#'  Temporal = 'day')
#'
#'
#' }
#' @export


grid_tas2SWAT <- function(

  tx = NULL,
  tn = NULL,
  Subbasins = NULL,
  DEM = NULL,
  cores = parallel::detectCores()-1,
  Star_Date = '1981-01-01',
  Temporal = 'day',
  dsn = getwd()
){

  # require(dplyr)
  tx <- raster::brick(tx)
  sp::proj4string(tx) <- sp::CRS("+init=epsg:4326")
  tn <- raster::brick(tn)
  sp::proj4string(tn) <- sp::CRS("+init=epsg:4326")
  sp::proj4string(Subbasins) <- sp::CRS("+init=epsg:4326")

  outp2 <- glue::glue(dsn,'/SWAT_inputs/Temperature/')
  ifelse(!dir.exists(outp2),xfun::dir_create(outp2),print('already exist!'))

  # verificar el shape
  if(!class(Subbasins) == 'SpatialPolygonsDataFrame') stop('subs shuld be a be a SpatialPolygonsDataFrame object', call. = FALSE)

  # verificar la proyecicon de subs con grid
  if(sp::is.projected(Subbasins)){
    stop('Error: Subs dont have projection', call. = FALSE)
  }  else {
    Subbasins <- sp::spTransform(Subbasins, raster::projection(tx))
  }

  as.numeric(Subbasins@data$Subbasin)
  Star_Date <- as.Date(Star_Date)
  dates <- seq.Date(from = Star_Date,
                    length.out = raster::nlayers(tx),
                    by = Temporal)
  end_day <- tail(dates,1)

  cell.numbers <- function(grid, geom){
    spacialcov <- grid
    spacialcov[] <- 1:raster::ncell(grid)
    position_rowcol <- function(i){
      quad1 <- unlist(raster::extract(x = spacialcov, y =  geom[i,], small = TRUE))
    }
    position <- lapply(1:length(geom), position_rowcol)
    return(position)
  }

  extract.fast <- function(grid, cells, fun = meam, na.rm = TRUE){
    matrix.r <- t(raster::as.matrix(grid))
    res <- sapply(1:length(cells), function(i){
      value <- matrix.r[cells[[i]]]
      fun(value, na.rm = na.rm)
    })
  }

  tictoc::tic('timer')
  cat('\f')
  cat('------------------------------------------------------------------------\n')
  cat('Extracting data from period:', as.character(Star_Date), 'to', as.character(end_day),'at',Temporal,'scale\n')
  cat('------------------------------------------------------------------------\n')

  cell.numberstx <- cell.numbers(grid = tx[[1]], geom = Subbasins)
  cell.numberstn <- cell.numbers(grid = tn[[1]], geom = Subbasins)
  #
  # Paralelizando
  if(!cores < parallel::detectCores()) cores <- parallel::detectCores()-1
  cl <- parallel::makeCluster(cores)

  parallel::clusterEvalQ(cl = cl, expr = c(library(raster)))
  parallel::clusterExport(cl = cl, varlist = c('tx',
                                               'tn',
                                               'cell.numberstx',
                                               'cell.numberstn',
                                               'extract.fast'),
                          envir = environment())

  # proceso de extraccion

  mean_t <- pbapply::pblapply(cl = cl, X = 1:raster::nlayers(tx), function(z){
    tmax <- extract.fast(grid = tx[[z]],
                         cells = cell.numberstx,
                         fun = mean,
                         na.rm = TRUE)

    tmin <- extract.fast(grid = tn[[z]],
                         cells = cell.numberstn,
                         fun = mean,
                         na.rm = TRUE)

    return(list(t_max = tmax, t_min =  tmin))
  })

  parallel::stopCluster(cl)

  mean_tx <- do.call(rbind, lapply(mean_t, function(z){z$t_max}))
  mean_tn <- do.call(rbind, lapply(mean_t, function(z){z$t_min}))

  lapply(1:ncol(mean_tx), FUN = function(i){
    tmax_i <- round(mean_tx[, i], 2)
    tmax_i[][is.na(mean_tx[])] <- -99
    tmax_i <- c(as.character(Star_Date), tmax_i)

    tmin_i <- round(mean_tn[, i], 2)
    tmin_i[][is.na(mean_tn[])] <- -99
    tmin_i <- c(as.character(Star_Date), tmin_i)

    tmax_tmin_i <- data.frame(tmax_i, tmin_i)

    write.table(x = tmax_tmin_i,
                paste(outp2, 'tmp_', sprintf(Subbasins@data$Subbasin[i]), '.txt', sep = ''),
                row.names = FALSE,
                quote = FALSE,
                col.names = FALSE,
                sep = ',')

    mod <- readLines(con = paste(outp2,
                                 'tmp_',
                                 sprintf(Subbasins@data$Subbasin[i]),
                                 '.txt',
                                 sep = ''))

    mod[1] <- as.character(paste(format(Star_Date, "%Y"),
                                 format(Star_Date, "%m"),
                                 format(Star_Date, "%d"),
                                 sep = ''))
    writeLines(mod ,paste(outp2,'tmp_',sprintf(Subbasins@data$Subbasin[i]),'.txt',sep = ''))
  })

  cat('\f')
  cat('-----------------------------------------------\n')
  cat('Writing main table of ubication for centroids!\n')
  cat('-----------------------------------------------\n')

  subs <- sp::spTransform(Subbasins, sp::CRS("+proj=longlat +datum=WGS84 +no_defs "))
  centroids <- rgeos::gCentroid(spgeom = subs, byid = TRUE)
  centroids <- sp::coordinates(centroids)

  elev <- raster::extract(raster::projectRaster(from = DEM,crs = '+proj=longlat +datum=WGS84 +no_defs'),centroids)

  subbasins_tp <- data.frame(ID = Subbasins@data$Subbasin,
                             NAME = paste('tmp_', Subbasins@data$Subbasin, sep = ''),
                             LAT = round(as.numeric(centroids[, 2]), 3),
                             LONG = round(as.numeric(centroids[, 1]), 3),
                             ELEVATION = round(as.numeric(elev), 3))

  write.table(subbasins_tp, paste(outp2, '/', 'tmp', '.txt', sep = ''),
              row.names = FALSE,
              quote = FALSE,
              col.names = TRUE,
              sep = ',')

  ubication <- subbasins_tp %>%
    dplyr::mutate(PRECIPITATION = paste0('pcp_',1:dim(subbasins_tp)[1])) %>%
    dplyr::rename(TEMPERATURE = NAME) %>%
    dplyr::select(ID, TEMPERATURE, PRECIPITATION,LAT,LONG,ELEVATION)

  fotify <- ggplot2::fortify(Subbasins)

  g <- ggplot2::ggplot()+
    ggplot2::geom_polygon(data = fotify, ggplot2::aes(long, lat, group = group, fill = hole),
                          colour = ggplot2::alpha("darkred", 1/2), size = 0.7) +
    ggplot2::geom_point(data = ubication, ggplot2::aes(LONG,LAT, size = ELEVATION), color = 'black', ptch = 16)+
    ggplot2::scale_fill_manual(values = c("gray95", "white")) +
    ggthemes::theme_pander()+
    ggplot2::labs(x = 'Longitude', y = 'Latitude', title = 'Points from which the information for each sub-basin was extracted',
                  subtitle = 'larger dots indicate higher altitude', caption = 'Plot generating by RWeatherTools R Package')+
    ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white"),
                   legend.position = "none")


  tictoc::toc(log = TRUE, quiet = TRUE)
  log.txt <- tictoc::tic.log(format = FALSE)
  tictoc::tic.clearlog()
  timings <- unlist(lapply(log.txt, function(x) x$toc - x$tic))
  cat('\f')
  cat('----------------------------------------------------------------------\n')
  message('Finis!!, time elapsed for pcp extraction:', round(timings/60,2),'minutes\n')
  cat('----------------------------------------------------------------------\n')

  gc(reset = TRUE)
  return(print(g))

}


